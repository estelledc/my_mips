Vivado Simulator 2018.3
Time resolution is 1 ps
时间=0: PC=00000000, 指令=xxxxxxxx, ALU=xxxxxxxx
寄存器写入使能激活: 写入r 0, 值=xxxxxxxx
时间=5000: PC=00000000, 指令=00000000, ALU=00000000
时间=20000: PC=00000004, 指令=00000000, ALU=00000000

==== 周期 1 ====
PC = 00000004, 指令 = 00000000
控制信号: opcode=000000, funct=000000
reg_dst=01, alu_src=0, mem_to_reg=00, reg_write=1, mem_write=0
alu_control=0000, branch=0, jump=0
R型指令:   未知R型
寄存器变化:
  r1: 00000000 -> 00000004
  r2: 00000000 -> 00000008
  r3: 00000000 -> 0000000c
  r4: 00000000 -> 00000010
  r5: 00000000 -> 00000014
  r6: 00000000 -> 00000018
  r7: 00000000 -> 0000001c
  r8: 00000000 -> 00000020
  r9: 00000000 -> 00000024
  r10: 00000000 -> 00000028
  r11: 00000000 -> 0000002c
  r12: 00000000 -> 00000030
  r13: 00000000 -> 00000034
  r14: 00000000 -> 00000038
  r15: 00000000 -> 0000003c
  r16: 00000000 -> 00000040
  r17: 00000000 -> 00000044
  r18: 00000000 -> 00000048
  r19: 00000000 -> 0000004c
  r20: 00000000 -> 00000050
  r21: 00000000 -> 00000054
  r22: 00000000 -> 00000058
  r23: 00000000 -> 0000005c
  r24: 00000000 -> 00000060
  r25: 00000000 -> 00000064
  r26: 00000000 -> 00000068
  r27: 00000000 -> 0000006c
  r28: 00000000 -> 00000070
  r29: 00000000 -> 00000074
  r30: 00000000 -> 00000078
  r31: 00000000 -> 0000007c
内存变化:
  mem[1]: 00000000 -> 00000004
  mem[2]: 00000000 -> 00000008
  mem[3]: 00000000 -> 0000000c
  mem[4]: 00000000 -> 00000010
  mem[5]: 00000000 -> 00000014
  mem[6]: 00000000 -> 00000018
  mem[7]: 00000000 -> 0000001c
  mem[8]: 00000000 -> 00000020
  mem[9]: 00000000 -> 00000024
  mem[10]: 00000000 -> 00000028
  mem[11]: 00000000 -> 0000002c
  mem[12]: 00000000 -> 00000030
  mem[13]: 00000000 -> 00000034
  mem[14]: 00000000 -> 00000038
  mem[15]: 00000000 -> 0000003c
  mem[16]: 00000000 -> 00000040
  mem[17]: 00000000 -> 00000044
  mem[18]: 00000000 -> 00000048
  mem[19]: 00000000 -> 0000004c
  mem[20]: 00000000 -> 00000050
  mem[21]: 00000000 -> 00000054
  mem[22]: 00000000 -> 00000058
  mem[23]: 00000000 -> 0000005c
  mem[24]: 00000000 -> 00000060
  mem[25]: 00000000 -> 00000064
  mem[26]: 00000000 -> 00000068
  mem[27]: 00000000 -> 0000006c
  mem[28]: 00000000 -> 00000070
  mem[29]: 00000000 -> 00000074
  mem[30]: 00000000 -> 00000078
  mem[31]: 00000000 -> 0000007c
  mem[32]: 00000000 -> 00000080
  mem[33]: 00000000 -> 00000084
  mem[34]: 00000000 -> 00000088
  mem[35]: 00000000 -> 0000008c
  mem[36]: 00000000 -> 00000090
  mem[37]: 00000000 -> 00000094
  mem[38]: 00000000 -> 00000098
  mem[39]: 00000000 -> 0000009c
  mem[40]: 00000000 -> 000000a0
  mem[41]: 00000000 -> 000000a4
  mem[42]: 00000000 -> 000000a8
  mem[43]: 00000000 -> 000000ac
  mem[44]: 00000000 -> 000000b0
  mem[45]: 00000000 -> 000000b4
  mem[46]: 00000000 -> 000000b8
  mem[47]: 00000000 -> 000000bc
  mem[48]: 00000000 -> 000000c0
  mem[49]: 00000000 -> 000000c4
  mem[50]: 00000000 -> 000000c8
  mem[51]: 00000000 -> 000000cc
  mem[52]: 00000000 -> 000000d0
  mem[53]: 00000000 -> 000000d4
  mem[54]: 00000000 -> 000000d8
  mem[55]: 00000000 -> 000000dc
  mem[56]: 00000000 -> 000000e0
  mem[57]: 00000000 -> 000000e4
  mem[58]: 00000000 -> 000000e8
  mem[59]: 00000000 -> 000000ec
  mem[60]: 00000000 -> 000000f0
  mem[61]: 00000000 -> 000000f4
  mem[62]: 00000000 -> 000000f8
  mem[63]: 00000000 -> 000000fc
ALU: a=00000000, b=00000000, result=00000000, zero=1
Next PC = 00000008
时间=25000: PC=00000004, 指令=00432020, ALU=00000014
时间=30000: PC=00000008, 指令=00432020, ALU=00000014

==== 周期 2 ====
PC = 00000008, 指令 = 00432020
控制信号: opcode=000000, funct=100000
reg_dst=01, alu_src=0, mem_to_reg=00, reg_write=1, mem_write=0
alu_control=0010, branch=0, jump=0
R型指令:       ADD
寄存器变化:
  r4: 00000010 -> 00000014
内存变化:
ALU: a=00000008, b=0000000c, result=00000014, zero=0
Next PC = 0000000c
时间=35000: PC=00000008, 指令=8c440004, ALU=0000000c
时间=40000: PC=0000000c, 指令=8c440004, ALU=0000000c

==== 周期 3 ====
PC = 0000000c, 指令 = 8c440004
控制信号: opcode=100011, funct=000100
reg_dst=00, alu_src=1, mem_to_reg=01, reg_write=1, mem_write=0
alu_control=0010, branch=0, jump=0
指令: LW r4, 4(r2)
寄存器变化:
内存变化:
ALU: a=00000008, b=00000004, result=0000000c, zero=0
Next PC = 00000010
时间=45000: PC=0000000c, 指令=ac450008, ALU=00000010
时间=50000: PC=00000010, 指令=ac450008, ALU=00000010

==== 周期 4 ====
PC = 00000010, 指令 = ac450008
控制信号: opcode=101011, funct=001000
reg_dst=00, alu_src=1, mem_to_reg=00, reg_write=0, mem_write=1
alu_control=0010, branch=0, jump=0
指令: SW r5, 8(r2)
寄存器变化:
内存变化:
  mem[4]: 00000010 -> 00000014
ALU: a=00000008, b=00000008, result=00000010, zero=0
Next PC = 00000014
寄存器写入使能激活: 写入r 2, 值=00000010
时间=55000: PC=00000010, 指令=00831022, ALU=00000008
时间=60000: PC=00000014, 指令=00831022, ALU=00000008

==== 周期 5 ====
PC = 00000014, 指令 = 00831022
控制信号: opcode=000000, funct=100010
reg_dst=01, alu_src=0, mem_to_reg=00, reg_write=1, mem_write=0
alu_control=0110, branch=0, jump=0
R型指令:       SUB
寄存器变化:
内存变化:
ALU: a=00000014, b=0000000c, result=00000008, zero=0
Next PC = 00000018
时间=65000: PC=00000014, 指令=00831025, ALU=0000001c
时间=70000: PC=00000018, 指令=00831025, ALU=0000001c

==== 周期 6 ====
PC = 00000018, 指令 = 00831025
控制信号: opcode=000000, funct=100101
reg_dst=01, alu_src=0, mem_to_reg=00, reg_write=1, mem_write=0
alu_control=0001, branch=0, jump=0
R型指令:        OR
寄存器变化:
  r2: 00000008 -> 0000001c
内存变化:
ALU: a=00000014, b=0000000c, result=0000001c, zero=0
Next PC = 0000001c
时间=75000: PC=00000018, 指令=00831024, ALU=00000004
时间=80000: PC=0000001c, 指令=00831024, ALU=00000004

==== 周期 7 ====
PC = 0000001c, 指令 = 00831024
控制信号: opcode=000000, funct=100100
reg_dst=01, alu_src=0, mem_to_reg=00, reg_write=1, mem_write=0
alu_control=0000, branch=0, jump=0
R型指令:       AND
寄存器变化:
内存变化:
ALU: a=00000014, b=0000000c, result=00000004, zero=0
Next PC = 00000020
时间=85000: PC=0000001c, 指令=0083102a, ALU=00000000
时间=90000: PC=00000020, 指令=0083102a, ALU=00000000

==== 周期 8 ====
PC = 00000020, 指令 = 0083102a
控制信号: opcode=000000, funct=101010
reg_dst=01, alu_src=0, mem_to_reg=00, reg_write=1, mem_write=0
alu_control=0111, branch=0, jump=0
R型指令:       SLT
寄存器变化:
  r2: 0000001c -> 00000000
内存变化:
ALU: a=00000014, b=0000000c, result=00000000, zero=1
Next PC = 00000024
时间=95000: PC=00000020, 指令=10630001, ALU=00000000
时间=100000: PC=00000028, 指令=10630001, ALU=00000000

==== 周期 9 ====
PC = 00000028, 指令 = 10630001
控制信号: opcode=000100, funct=000001
reg_dst=00, alu_src=0, mem_to_reg=00, reg_write=0, mem_write=0
alu_control=0110, branch=1, jump=0
指令: BEQ r3, r3, 1
寄存器变化:
内存变化:
ALU: a=0000000c, b=0000000c, result=00000000, zero=1
Next PC = 00000030
时间=105000: PC=00000028, 指令=10640001, ALU=fffffff8
时间=110000: PC=00000030, 指令=10640001, ALU=fffffff8

==== 周期 10 ====
PC = 00000030, 指令 = 10640001
控制信号: opcode=000100, funct=000001
reg_dst=00, alu_src=0, mem_to_reg=00, reg_write=0, mem_write=0
alu_control=0110, branch=1, jump=0
指令: BEQ r3, r4, 1
寄存器变化:
内存变化:
ALU: a=0000000c, b=00000014, result=fffffff8, zero=0
Next PC = 00000038
时间=115000: PC=00000030, 指令=08000000, ALU=00000000
时间=120000: PC=00000000, 指令=08000000, ALU=00000000

==== 周期 11 ====
PC = 00000000, 指令 = 08000000
控制信号: opcode=000010, funct=000000
reg_dst=00, alu_src=0, mem_to_reg=00, reg_write=0, mem_write=0
alu_control=0000, branch=0, jump=1
指令: J 00000000
寄存器变化:
内存变化:
ALU: a=00000000, b=00000000, result=00000000, zero=1
Next PC = 00000000
寄存器写入使能激活: 写入r 0, 值=00000000
时间=125000: PC=00000000, 指令=00000000, ALU=00000000
时间=130000: PC=00000004, 指令=00000000, ALU=00000000

==== 周期 12 ====
PC = 00000004, 指令 = 00000000
控制信号: opcode=000000, funct=000000
reg_dst=01, alu_src=0, mem_to_reg=00, reg_write=1, mem_write=0
alu_control=0000, branch=0, jump=0
R型指令:   未知R型
寄存器变化:
内存变化:
ALU: a=00000000, b=00000000, result=00000000, zero=1
Next PC = 00000008
时间=135000: PC=00000004, 指令=00432020, ALU=0000000c
时间=140000: PC=00000008, 指令=00432020, ALU=0000000c

==== 周期 13 ====
PC = 00000008, 指令 = 00432020
控制信号: opcode=000000, funct=100000
reg_dst=01, alu_src=0, mem_to_reg=00, reg_write=1, mem_write=0
alu_control=0010, branch=0, jump=0
R型指令:       ADD
寄存器变化:
内存变化:
ALU: a=00000000, b=0000000c, result=0000000c, zero=0
Next PC = 0000000c
时间=145000: PC=00000008, 指令=8c440004, ALU=00000004
时间=150000: PC=0000000c, 指令=8c440004, ALU=00000004

==== 周期 14 ====
PC = 0000000c, 指令 = 8c440004
控制信号: opcode=100011, funct=000100
reg_dst=00, alu_src=1, mem_to_reg=01, reg_write=1, mem_write=0
alu_control=0010, branch=0, jump=0
指令: LW r4, 4(r2)
寄存器变化:
  r4: 00000014 -> 00000004
内存变化:
ALU: a=00000000, b=00000004, result=00000004, zero=0
Next PC = 00000010
时间=155000: PC=0000000c, 指令=ac450008, ALU=00000008
时间=160000: PC=00000010, 指令=ac450008, ALU=00000008

==== 周期 15 ====
PC = 00000010, 指令 = ac450008
控制信号: opcode=101011, funct=001000
reg_dst=00, alu_src=1, mem_to_reg=00, reg_write=0, mem_write=1
alu_control=0010, branch=0, jump=0
指令: SW r5, 8(r2)
寄存器变化:
内存变化:
ALU: a=00000000, b=00000008, result=00000008, zero=0
Next PC = 00000014
寄存器写入使能激活: 写入r 2, 值=00000008
时间=165000: PC=00000010, 指令=00831022, ALU=fffffff8
时间=170000: PC=00000014, 指令=00831022, ALU=fffffff8

==== 周期 16 ====
PC = 00000014, 指令 = 00831022
控制信号: opcode=000000, funct=100010
reg_dst=01, alu_src=0, mem_to_reg=00, reg_write=1, mem_write=0
alu_control=0110, branch=0, jump=0
R型指令:       SUB
寄存器变化:
  r2: 00000000 -> fffffff8
内存变化:
ALU: a=00000004, b=0000000c, result=fffffff8, zero=0
Next PC = 00000018
时间=175000: PC=00000014, 指令=00831025, ALU=0000000c
时间=180000: PC=00000018, 指令=00831025, ALU=0000000c

==== 周期 17 ====
PC = 00000018, 指令 = 00831025
控制信号: opcode=000000, funct=100101
reg_dst=01, alu_src=0, mem_to_reg=00, reg_write=1, mem_write=0
alu_control=0001, branch=0, jump=0
R型指令:        OR
寄存器变化:
内存变化:
ALU: a=00000004, b=0000000c, result=0000000c, zero=0
Next PC = 0000001c
时间=185000: PC=00000018, 指令=00831024, ALU=00000004
时间=190000: PC=0000001c, 指令=00831024, ALU=00000004

==== 周期 18 ====
PC = 0000001c, 指令 = 00831024
控制信号: opcode=000000, funct=100100
reg_dst=01, alu_src=0, mem_to_reg=00, reg_write=1, mem_write=0
alu_control=0000, branch=0, jump=0
R型指令:       AND
寄存器变化:
  r2: fffffff8 -> 00000004
内存变化:
ALU: a=00000004, b=0000000c, result=00000004, zero=0
Next PC = 00000020
时间=195000: PC=0000001c, 指令=0083102a, ALU=00000001
时间=200000: PC=00000020, 指令=0083102a, ALU=00000001

==== 周期 19 ====
PC = 00000020, 指令 = 0083102a
控制信号: opcode=000000, funct=101010
reg_dst=01, alu_src=0, mem_to_reg=00, reg_write=1, mem_write=0
alu_control=0111, branch=0, jump=0
R型指令:       SLT
寄存器变化:
内存变化:
ALU: a=00000004, b=0000000c, result=00000001, zero=0
Next PC = 00000024
时间=205000: PC=00000020, 指令=10630001, ALU=00000000
时间=210000: PC=00000028, 指令=10630001, ALU=00000000

==== 周期 20 ====
PC = 00000028, 指令 = 10630001
控制信号: opcode=000100, funct=000001
reg_dst=00, alu_src=0, mem_to_reg=00, reg_write=0, mem_write=0
alu_control=0110, branch=1, jump=0
指令: BEQ r3, r3, 1
寄存器变化:
内存变化:
ALU: a=0000000c, b=0000000c, result=00000000, zero=1
Next PC = 00000030
时间=215000: PC=00000028, 指令=10640001, ALU=00000008
时间=220000: PC=00000030, 指令=10640001, ALU=00000008

==== 周期 21 ====
PC = 00000030, 指令 = 10640001
控制信号: opcode=000100, funct=000001
reg_dst=00, alu_src=0, mem_to_reg=00, reg_write=0, mem_write=0
alu_control=0110, branch=1, jump=0
指令: BEQ r3, r4, 1
寄存器变化:
内存变化:
ALU: a=0000000c, b=00000004, result=00000008, zero=0
Next PC = 00000038
时间=225000: PC=00000030, 指令=08000000, ALU=00000000
时间=230000: PC=00000000, 指令=08000000, ALU=00000000

==== 周期 22 ====
PC = 00000000, 指令 = 08000000
控制信号: opcode=000010, funct=000000
reg_dst=00, alu_src=0, mem_to_reg=00, reg_write=0, mem_write=0
alu_control=0000, branch=0, jump=1
指令: J 00000000
寄存器变化:
内存变化:
ALU: a=00000000, b=00000000, result=00000000, zero=1
Next PC = 00000000
寄存器写入使能激活: 写入r 0, 值=00000000
时间=235000: PC=00000000, 指令=00000000, ALU=00000000
时间=240000: PC=00000004, 指令=00000000, ALU=00000000

==== 周期 23 ====
PC = 00000004, 指令 = 00000000
控制信号: opcode=000000, funct=000000
reg_dst=01, alu_src=0, mem_to_reg=00, reg_write=1, mem_write=0
alu_control=0000, branch=0, jump=0
R型指令:   未知R型
寄存器变化:
内存变化:
ALU: a=00000000, b=00000000, result=00000000, zero=1
Next PC = 00000008
时间=245000: PC=00000004, 指令=00432020, ALU=00000010
时间=250000: PC=00000008, 指令=00432020, ALU=00000010

==== 周期 24 ====
PC = 00000008, 指令 = 00432020
控制信号: opcode=000000, funct=100000
reg_dst=01, alu_src=0, mem_to_reg=00, reg_write=1, mem_write=0
alu_control=0010, branch=0, jump=0
R型指令:       ADD
寄存器变化:
  r4: 00000004 -> 00000010
内存变化:
ALU: a=00000004, b=0000000c, result=00000010, zero=0
Next PC = 0000000c
时间=255000: PC=00000008, 指令=8c440004, ALU=00000008
时间=260000: PC=0000000c, 指令=8c440004, ALU=00000008

==== 周期 25 ====
PC = 0000000c, 指令 = 8c440004
控制信号: opcode=100011, funct=000100
reg_dst=00, alu_src=1, mem_to_reg=01, reg_write=1, mem_write=0
alu_control=0010, branch=0, jump=0
指令: LW r4, 4(r2)
寄存器变化:
内存变化:
ALU: a=00000004, b=00000004, result=00000008, zero=0
Next PC = 00000010
时间=265000: PC=0000000c, 指令=ac450008, ALU=0000000c
时间=270000: PC=00000010, 指令=ac450008, ALU=0000000c

==== 周期 26 ====
PC = 00000010, 指令 = ac450008
控制信号: opcode=101011, funct=001000
reg_dst=00, alu_src=1, mem_to_reg=00, reg_write=0, mem_write=1
alu_control=0010, branch=0, jump=0
指令: SW r5, 8(r2)
寄存器变化:
内存变化:
  mem[3]: 0000000c -> 00000014
ALU: a=00000004, b=00000008, result=0000000c, zero=0
Next PC = 00000014
寄存器写入使能激活: 写入r 2, 值=0000000c
时间=275000: PC=00000010, 指令=00831022, ALU=00000004
时间=280000: PC=00000014, 指令=00831022, ALU=00000004

==== 周期 27 ====
PC = 00000014, 指令 = 00831022
控制信号: opcode=000000, funct=100010
reg_dst=01, alu_src=0, mem_to_reg=00, reg_write=1, mem_write=0
alu_control=0110, branch=0, jump=0
R型指令:       SUB
寄存器变化:
内存变化:
ALU: a=00000010, b=0000000c, result=00000004, zero=0
Next PC = 00000018
时间=285000: PC=00000014, 指令=00831025, ALU=0000001c
时间=290000: PC=00000018, 指令=00831025, ALU=0000001c

==== 周期 28 ====
PC = 00000018, 指令 = 00831025
控制信号: opcode=000000, funct=100101
reg_dst=01, alu_src=0, mem_to_reg=00, reg_write=1, mem_write=0
alu_control=0001, branch=0, jump=0
R型指令:        OR
寄存器变化:
  r2: 00000004 -> 0000001c
内存变化:
ALU: a=00000010, b=0000000c, result=0000001c, zero=0
Next PC = 0000001c
时间=295000: PC=00000018, 指令=00831024, ALU=00000000
时间=300000: PC=0000001c, 指令=00831024, ALU=00000000

==== 周期 29 ====
PC = 0000001c, 指令 = 00831024
控制信号: opcode=000000, funct=100100
reg_dst=01, alu_src=0, mem_to_reg=00, reg_write=1, mem_write=0
alu_control=0000, branch=0, jump=0
R型指令:       AND
寄存器变化:
内存变化:
ALU: a=00000010, b=0000000c, result=00000000, zero=1
Next PC = 00000020
时间=305000: PC=0000001c, 指令=0083102a, ALU=00000000
时间=310000: PC=00000020, 指令=0083102a, ALU=00000000

==== 周期 30 ====
PC = 00000020, 指令 = 0083102a
控制信号: opcode=000000, funct=101010
reg_dst=01, alu_src=0, mem_to_reg=00, reg_write=1, mem_write=0
alu_control=0111, branch=0, jump=0
R型指令:       SLT
寄存器变化:
  r2: 0000001c -> 00000000
内存变化:
ALU: a=00000010, b=0000000c, result=00000000, zero=1
Next PC = 00000024
时间=315000: PC=00000020, 指令=10630001, ALU=00000000
时间=320000: PC=00000028, 指令=10630001, ALU=00000000

==== 周期 31 ====
PC = 00000028, 指令 = 10630001
控制信号: opcode=000100, funct=000001
reg_dst=00, alu_src=0, mem_to_reg=00, reg_write=0, mem_write=0
alu_control=0110, branch=1, jump=0
指令: BEQ r3, r3, 1
寄存器变化:
内存变化:
ALU: a=0000000c, b=0000000c, result=00000000, zero=1
Next PC = 00000030
时间=325000: PC=00000028, 指令=10640001, ALU=fffffffc
时间=330000: PC=00000030, 指令=10640001, ALU=fffffffc

==== 周期 32 ====
PC = 00000030, 指令 = 10640001
控制信号: opcode=000100, funct=000001
reg_dst=00, alu_src=0, mem_to_reg=00, reg_write=0, mem_write=0
alu_control=0110, branch=1, jump=0
指令: BEQ r3, r4, 1
寄存器变化:
内存变化:
ALU: a=0000000c, b=00000010, result=fffffffc, zero=0
Next PC = 00000038
时间=335000: PC=00000030, 指令=08000000, ALU=00000000
时间=340000: PC=00000000, 指令=08000000, ALU=00000000

==== 周期 33 ====
PC = 00000000, 指令 = 08000000
控制信号: opcode=000010, funct=000000
reg_dst=00, alu_src=0, mem_to_reg=00, reg_write=0, mem_write=0
alu_control=0000, branch=0, jump=1
指令: J 00000000
寄存器变化:
内存变化:
ALU: a=00000000, b=00000000, result=00000000, zero=1
Next PC = 00000000
寄存器写入使能激活: 写入r 0, 值=00000000
时间=345000: PC=00000000, 指令=00000000, ALU=00000000
时间=350000: PC=00000004, 指令=00000000, ALU=00000000

==== 周期 34 ====
PC = 00000004, 指令 = 00000000
控制信号: opcode=000000, funct=000000
reg_dst=01, alu_src=0, mem_to_reg=00, reg_write=1, mem_write=0
alu_control=0000, branch=0, jump=0
R型指令:   未知R型
寄存器变化:
内存变化:
ALU: a=00000000, b=00000000, result=00000000, zero=1
Next PC = 00000008
时间=355000: PC=00000004, 指令=00432020, ALU=0000000c
时间=360000: PC=00000008, 指令=00432020, ALU=0000000c

==== 周期 35 ====
PC = 00000008, 指令 = 00432020
控制信号: opcode=000000, funct=100000
reg_dst=01, alu_src=0, mem_to_reg=00, reg_write=1, mem_write=0
alu_control=0010, branch=0, jump=0
R型指令:       ADD
寄存器变化:
内存变化:
ALU: a=00000000, b=0000000c, result=0000000c, zero=0
Next PC = 0000000c
时间=365000: PC=00000008, 指令=8c440004, ALU=00000004
时间=370000: PC=0000000c, 指令=8c440004, ALU=00000004

==== 周期 36 ====
PC = 0000000c, 指令 = 8c440004
控制信号: opcode=100011, funct=000100
reg_dst=00, alu_src=1, mem_to_reg=01, reg_write=1, mem_write=0
alu_control=0010, branch=0, jump=0
指令: LW r4, 4(r2)
寄存器变化:
  r4: 00000010 -> 00000004
内存变化:
ALU: a=00000000, b=00000004, result=00000004, zero=0
Next PC = 00000010
时间=375000: PC=0000000c, 指令=ac450008, ALU=00000008
时间=380000: PC=00000010, 指令=ac450008, ALU=00000008

==== 周期 37 ====
PC = 00000010, 指令 = ac450008
控制信号: opcode=101011, funct=001000
reg_dst=00, alu_src=1, mem_to_reg=00, reg_write=0, mem_write=1
alu_control=0010, branch=0, jump=0
指令: SW r5, 8(r2)
寄存器变化:
内存变化:
ALU: a=00000000, b=00000008, result=00000008, zero=0
Next PC = 00000014
寄存器写入使能激活: 写入r 2, 值=00000008
时间=385000: PC=00000010, 指令=00831022, ALU=fffffff8
时间=390000: PC=00000014, 指令=00831022, ALU=fffffff8

==== 周期 38 ====
PC = 00000014, 指令 = 00831022
控制信号: opcode=000000, funct=100010
reg_dst=01, alu_src=0, mem_to_reg=00, reg_write=1, mem_write=0
alu_control=0110, branch=0, jump=0
R型指令:       SUB
寄存器变化:
  r2: 00000000 -> fffffff8
内存变化:
ALU: a=00000004, b=0000000c, result=fffffff8, zero=0
Next PC = 00000018
时间=395000: PC=00000014, 指令=00831025, ALU=0000000c
时间=400000: PC=00000018, 指令=00831025, ALU=0000000c

==== 周期 39 ====
PC = 00000018, 指令 = 00831025
控制信号: opcode=000000, funct=100101
reg_dst=01, alu_src=0, mem_to_reg=00, reg_write=1, mem_write=0
alu_control=0001, branch=0, jump=0
R型指令:        OR
寄存器变化:
内存变化:
ALU: a=00000004, b=0000000c, result=0000000c, zero=0
Next PC = 0000001c
时间=405000: PC=00000018, 指令=00831024, ALU=00000004
时间=410000: PC=0000001c, 指令=00831024, ALU=00000004

==== 周期 40 ====
PC = 0000001c, 指令 = 00831024
控制信号: opcode=000000, funct=100100
reg_dst=01, alu_src=0, mem_to_reg=00, reg_write=1, mem_write=0
alu_control=0000, branch=0, jump=0
R型指令:       AND
寄存器变化:
  r2: fffffff8 -> 00000004
内存变化:
ALU: a=00000004, b=0000000c, result=00000004, zero=0
Next PC = 00000020
时间=415000: PC=0000001c, 指令=0083102a, ALU=00000001
时间=420000: PC=00000020, 指令=0083102a, ALU=00000001

==== 周期 41 ====
PC = 00000020, 指令 = 0083102a
控制信号: opcode=000000, funct=101010
reg_dst=01, alu_src=0, mem_to_reg=00, reg_write=1, mem_write=0
alu_control=0111, branch=0, jump=0
R型指令:       SLT
寄存器变化:
内存变化:
ALU: a=00000004, b=0000000c, result=00000001, zero=0
Next PC = 00000024
时间=425000: PC=00000020, 指令=10630001, ALU=00000000
时间=430000: PC=00000028, 指令=10630001, ALU=00000000

==== 周期 42 ====
PC = 00000028, 