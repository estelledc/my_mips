Vivado Simulator 2018.3
Time resolution is 1 ps

==== 周期 1 ====
PC = 00000004, 指令 = 00432020
控制信号: opcode=000000, funct=100000
reg_dst=01, alu_src=0, mem_to_reg=00, reg_write=1, mem_write=0
alu_control=0010, branch=0, jump=0
R型指令:       ADD
寄存器变化:
  r1: 00000000 -> 00000004
  r2: 00000000 -> 00000008
  r3: 00000000 -> 0000000c
  r4: 00000000 -> 00000010
  r5: 00000000 -> 00000014
  r6: 00000000 -> 00000018
  r7: 00000000 -> 0000001c
  r8: 00000000 -> 00000020
  r9: 00000000 -> 00000024
  r10: 00000000 -> 00000028
  r11: 00000000 -> 0000002c
  r12: 00000000 -> 00000030
  r13: 00000000 -> 00000034
  r14: 00000000 -> 00000038
  r15: 00000000 -> 0000003c
  r16: 00000000 -> 00000040
  r17: 00000000 -> 00000044
  r18: 00000000 -> 00000048
  r19: 00000000 -> 0000004c
  r20: 00000000 -> 00000050
  r21: 00000000 -> 00000054
  r22: 00000000 -> 00000058
  r23: 00000000 -> 0000005c
  r24: 00000000 -> 00000060
  r25: 00000000 -> 00000064
  r26: 00000000 -> 00000068
  r27: 00000000 -> 0000006c
  r28: 00000000 -> 00000070
  r29: 00000000 -> 00000074
  r30: 00000000 -> 00000078
  r31: 00000000 -> 0000007c
内存变化:
  mem[1]: 00000000 -> 00000004
  mem[2]: 00000000 -> 00000008
  mem[3]: 00000000 -> 0000000c
  mem[4]: 00000000 -> 00000010
  mem[5]: 00000000 -> 00000014
  mem[6]: 00000000 -> 00000018
  mem[7]: 00000000 -> 0000001c
  mem[8]: 00000000 -> 00000020
  mem[9]: 00000000 -> 00000024
  mem[10]: 00000000 -> 00000028
  mem[11]: 00000000 -> 0000002c
  mem[12]: 00000000 -> 00000030
  mem[13]: 00000000 -> 00000034
  mem[14]: 00000000 -> 00000038
  mem[15]: 00000000 -> 0000003c
  mem[16]: 00000000 -> 00000040
  mem[17]: 00000000 -> 00000044
  mem[18]: 00000000 -> 00000048
  mem[19]: 00000000 -> 0000004c
  mem[20]: 00000000 -> 00000050
  mem[21]: 00000000 -> 00000054
  mem[22]: 00000000 -> 00000058
  mem[23]: 00000000 -> 0000005c
  mem[24]: 00000000 -> 00000060
  mem[25]: 00000000 -> 00000064
  mem[26]: 00000000 -> 00000068
  mem[27]: 00000000 -> 0000006c
  mem[28]: 00000000 -> 00000070
  mem[29]: 00000000 -> 00000074
  mem[30]: 00000000 -> 00000078
  mem[31]: 00000000 -> 0000007c
  mem[32]: 00000000 -> 00000080
  mem[33]: 00000000 -> 00000084
  mem[34]: 00000000 -> 00000088
  mem[35]: 00000000 -> 0000008c
  mem[36]: 00000000 -> 00000090
  mem[37]: 00000000 -> 00000094
  mem[38]: 00000000 -> 00000098
  mem[39]: 00000000 -> 0000009c
  mem[40]: 00000000 -> 000000a0
  mem[41]: 00000000 -> 000000a4
  mem[42]: 00000000 -> 000000a8
  mem[43]: 00000000 -> 000000ac
  mem[44]: 00000000 -> 000000b0
  mem[45]: 00000000 -> 000000b4
  mem[46]: 00000000 -> 000000b8
  mem[47]: 00000000 -> 000000bc
  mem[48]: 00000000 -> 000000c0
  mem[49]: 00000000 -> 000000c4
  mem[50]: 00000000 -> 000000c8
  mem[51]: 00000000 -> 000000cc
  mem[52]: 00000000 -> 000000d0
  mem[53]: 00000000 -> 000000d4
  mem[54]: 00000000 -> 000000d8
  mem[55]: 00000000 -> 000000dc
  mem[56]: 00000000 -> 000000e0
  mem[57]: 00000000 -> 000000e4
  mem[58]: 00000000 -> 000000e8
  mem[59]: 00000000 -> 000000ec
  mem[60]: 00000000 -> 000000f0
  mem[61]: 00000000 -> 000000f4
  mem[62]: 00000000 -> 000000f8
  mem[63]: 00000000 -> 000000fc
ALU: a=00000008, b=0000000c, result=00000014, zero=0
Next PC = 00000008

==== 周期 2 ====
PC = 00000008, 指令 = 8c440004
控制信号: opcode=100011, funct=000100
reg_dst=00, alu_src=1, mem_to_reg=01, reg_write=1, mem_write=0
alu_control=0010, branch=0, jump=0
指令: LW r4, 4(r2)
寄存器变化:
  r4: 00000010 -> 0000000c
内存变化:
ALU: a=00000008, b=00000004, result=0000000c, zero=0
Next PC = 0000000c

==== 周期 3 ====
PC = 0000000c, 指令 = 8c440004
控制信号: opcode=100011, funct=000100
reg_dst=00, alu_src=1, mem_to_reg=01, reg_write=1, mem_write=0
alu_control=0010, branch=0, jump=0
指令: LW r4, 4(r2)
寄存器变化:
内存变化:
ALU: a=00000008, b=00000004, result=0000000c, zero=0
Next PC = 00000010

==== 周期 4 ====
PC = 00000010, 指令 = 00831022
控制信号: opcode=000000, funct=100010
reg_dst=01, alu_src=0, mem_to_reg=00, reg_write=1, mem_write=0
alu_control=0110, branch=0, jump=0
R型指令:       SUB
寄存器变化:
  r2: 00000008 -> 00000000
内存变化:
ALU: a=0000000c, b=0000000c, result=00000000, zero=1
Next PC = 00000014

==== 周期 5 ====
PC = 00000014, 指令 = 00831022
控制信号: opcode=000000, funct=100010
reg_dst=01, alu_src=0, mem_to_reg=00, reg_write=1, mem_write=0
alu_control=0110, branch=0, jump=0
R型指令:       SUB
寄存器变化:
内存变化:
ALU: a=0000000c, b=0000000c, result=00000000, zero=1
Next PC = 00000018

==== 周期 6 ====
PC = 00000018, 指令 = 00831024
控制信号: opcode=000000, funct=100100
reg_dst=01, alu_src=0, mem_to_reg=00, reg_write=1, mem_write=0
alu_control=0000, branch=0, jump=0
R型指令:       AND
寄存器变化:
  r2: 00000000 -> 0000000c
内存变化:
ALU: a=0000000c, b=0000000c, result=0000000c, zero=0
Next PC = 0000001c

==== 周期 7 ====
PC = 0000001c, 指令 = 00831024
控制信号: opcode=000000, funct=100100
reg_dst=01, alu_src=0, mem_to_reg=00, reg_write=1, mem_write=0
alu_control=0000, branch=0, jump=0
R型指令:       AND
寄存器变化:
内存变化:
ALU: a=0000000c, b=0000000c, result=0000000c, zero=0
Next PC = 00000020

==== 周期 8 ====
PC = 00000024, 指令 = 10630001
控制信号: opcode=000100, funct=000001
reg_dst=00, alu_src=0, mem_to_reg=00, reg_write=0, mem_write=0
alu_control=0110, branch=1, jump=0
指令: BEQ r3, r3, 1
寄存器变化:
内存变化:
ALU: a=0000000c, b=0000000c, result=00000000, zero=1
Next PC = 0000002c

==== 周期 9 ====
PC = 0000002c, 指令 = 10630001
控制信号: opcode=000100, funct=000001
reg_dst=00, alu_src=0, mem_to_reg=00, reg_write=0, mem_write=0
alu_control=0110, branch=1, jump=0
指令: BEQ r3, r3, 1
寄存器变化:
内存变化:
ALU: a=0000000c, b=0000000c, result=00000000, zero=1
Next PC = 00000034

==== 周期 10 ====
PC = 00000000, 指令 = 08000000
控制信号: opcode=000010, funct=000000
reg_dst=00, alu_src=0, mem_to_reg=00, reg_write=0, mem_write=0
alu_control=0000, branch=0, jump=1
指令: J 00000000
寄存器变化:
内存变化:
ALU: a=00000000, b=00000000, result=00000000, zero=1
Next PC = 00000000

==== 周期 11 ====
PC = 00000000, 指令 = 08000000
控制信号: opcode=000010, funct=000000
reg_dst=00, alu_src=0, mem_to_reg=00, reg_write=0, mem_write=0
alu_control=0000, branch=0, jump=1
指令: J 00000000
寄存器变化:
内存变化:
ALU: a=00000000, b=00000000, result=00000000, zero=1
Next PC = 00000000

==== 周期 12 ====
PC = 00000004, 指令 = 00432020
控制信号: opcode=000000, funct=100000
reg_dst=01, alu_src=0, mem_to_reg=00, reg_write=1, mem_write=0
alu_control=0010, branch=0, jump=0
R型指令:       ADD
寄存器变化:
  r4: 0000000c -> 00000018
内存变化:
ALU: a=0000000c, b=0000000c, result=00000018, zero=0
Next PC = 00000008

==== 周期 13 ====
PC = 00000008, 指令 = 00432020
控制信号: opcode=000000, funct=100000
reg_dst=01, alu_src=0, mem_to_reg=00, reg_write=1, mem_write=0
alu_control=0010, branch=0, jump=0
R型指令:       ADD
寄存器变化:
内存变化:
ALU: a=0000000c, b=0000000c, result=00000018, zero=0
Next PC = 0000000c

==== 周期 14 ====
PC = 0000000c, 指令 = ac450008
控制信号: opcode=101011, funct=001000
reg_dst=00, alu_src=1, mem_to_reg=00, reg_write=0, mem_write=1
alu_control=0010, branch=0, jump=0
指令: SW r5, 8(r2)
寄存器变化:
内存变化:
ALU: a=0000000c, b=00000008, result=00000014, zero=0
Next PC = 00000010

==== 周期 15 ====
PC = 00000010, 指令 = ac450008
控制信号: opcode=101011, funct=001000
reg_dst=00, alu_src=1, mem_to_reg=00, reg_write=0, mem_write=1
alu_control=0010, branch=0, jump=0
指令: SW r5, 8(r2)
寄存器变化:
内存变化:
ALU: a=0000000c, b=00000008, result=00000014, zero=0
Next PC = 00000014

==== 周期 16 ====
PC = 00000014, 指令 = 00831025
控制信号: opcode=000000, funct=100101
reg_dst=01, alu_src=0, mem_to_reg=00, reg_write=1, mem_write=0
alu_control=0001, branch=0, jump=0
R型指令:        OR
寄存器变化:
  r2: 0000000c -> 0000001c
内存变化:
ALU: a=00000018, b=0000000c, result=0000001c, zero=0
Next PC = 00000018

==== 周期 17 ====
PC = 00000018, 指令 = 00831025
控制信号: opcode=000000, funct=100101
reg_dst=01, alu_src=0, mem_to_reg=00, reg_write=1, mem_write=0
alu_control=0001, branch=0, jump=0
R型指令:        OR
寄存器变化:
内存变化:
ALU: a=00000018, b=0000000c, result=0000001c, zero=0
Next PC = 0000001c

==== 周期 18 ====
PC = 0000001c, 指令 = 0083102a
控制信号: opcode=000000, funct=101010
reg_dst=01, alu_src=0, mem_to_reg=00, reg_write=1, mem_write=0
alu_control=0111, branch=0, jump=0
R型指令:       SLT
寄存器变化:
  r2: 0000001c -> 00000000
内存变化:
ALU: a=00000018, b=0000000c, result=00000000, zero=1
Next PC = 00000020

==== 周期 19 ====
PC = 00000020, 指令 = 0083102a
控制信号: opcode=000000, funct=101010
reg_dst=01, alu_src=0, mem_to_reg=00, reg_write=1, mem_write=0
alu_control=0111, branch=0, jump=0
R型指令:       SLT
寄存器变化:
内存变化:
ALU: a=00000018, b=0000000c, result=00000000, zero=1
Next PC = 00000024

==== 周期 20 ====
PC = 00000024, 指令 = 8c620000
控制信号: opcode=100011, funct=000000
reg_dst=00, alu_src=1, mem_to_reg=01, reg_write=1, mem_write=0
alu_control=0010, branch=0, jump=0
指令: LW r2, 0(r3)
寄存器变化:
  r2: 00000000 -> 0000000c
内存变化:
ALU: a=0000000c, b=00000000, result=0000000c, zero=0
Next PC = 00000028

==== 周期 21 ====
PC = 00000028, 指令 = 8c620000
控制信号: opcode=100011, funct=000000
reg_dst=00, alu_src=1, mem_to_reg=01, reg_write=1, mem_write=0
alu_control=0010, branch=0, jump=0
指令: LW r2, 0(r3)
寄存器变化:
内存变化:
ALU: a=0000000c, b=00000000, result=0000000c, zero=0
Next PC = 0000002c

==== 周期 22 ====
PC = 0000002c, 指令 = ac620000
控制信号: opcode=101011, funct=000000
reg_dst=00, alu_src=1, mem_to_reg=00, reg_write=0, mem_write=1
alu_control=0010, branch=0, jump=0
指令: SW r2, 0(r3)
寄存器变化:
内存变化:
ALU: a=0000000c, b=00000000, result=0000000c, zero=0
Next PC = 00000030

==== 周期 23 ====
PC = 00000030, 指令 = ac620000
控制信号: opcode=101011, funct=000000
reg_dst=00, alu_src=1, mem_to_reg=00, reg_write=0, mem_write=1
alu_control=0010, branch=0, jump=0
指令: SW r2, 0(r3)
寄存器变化:
内存变化:
ALU: a=0000000c, b=00000000, result=0000000c, zero=0
Next PC = 00000034

==== 周期 24 ====
PC = 00000034, 指令 = xxxxxxxx
控制信号: opcode=xxxxxx, funct=xxxxxx
reg_dst=00, alu_src=0, mem_to_reg=00, reg_write=0, mem_write=0
alu_control=0000, branch=0, jump=0
其他指令类型
寄存器变化:
内存变化:
ALU: a=xxxxxxxx, b=xxxxxxxx, result=xxxxxxxx, zero=x
Next PC = 00000038

==== 周期 25 ====
PC = 00000038, 指令 = xxxxxxxx
控制信号: opcode=xxxxxx, funct=xxxxxx
reg_dst=00, alu_src=0, mem_to_reg=00, reg_write=0, mem_write=0
alu_control=0000, branch=0, jump=0
其他指令类型
寄存器变化:
内存变化:
ALU: a=xxxxxxxx, b=xxxxxxxx, result=xxxxxxxx, zero=x
Next PC = 0000003c

==== 周期 26 ====
PC = 0000003c, 指令 = xxxxxxxx
控制信号: opcode=xxxxxx, funct=xxxxxx
reg_dst=00, alu_src=0, mem_to_reg=00, reg_write=0, mem_write=0
alu_control=0000, branch=0, jump=0
其他指令类型
寄存器变化:
内存变化:
ALU: a=xxxxxxxx, b=xxxxxxxx, result=xxxxxxxx, zero=x
Next PC = 00000040

==== 周期 27 ====
PC = 00000040, 指令 = xxxxxxxx
控制信号: opcode=xxxxxx, funct=xxxxxx
reg_dst=00, alu_src=0, mem_to_reg=00, reg_write=0, mem_write=0
alu_control=0000, branch=0, jump=0
其他指令类型
寄存器变化:
内存变化:
ALU: a=xxxxxxxx, b=xxxxxxxx, result=xxxxxxxx, zero=x
Next PC = 00000044

==== 周期 28 ====
PC = 00000044, 指令 = xxxxxxxx
控制信号: opcode=xxxxxx, funct=xxxxxx
reg_dst=00, alu_src=0, mem_to_reg=00, reg_write=0, mem_write=0
alu_control=0000, branch=0, jump=0
其他指令类型
寄存器变化:
内存变化:
ALU: a=xxxxxxxx, b=xxxxxxxx, result=xxxxxxxx, zero=x
Next PC = 00000048

==== 周期 29 ====
PC = 00000048, 指令 = xxxxxxxx
控制信号: opcode=xxxxxx, funct=xxxxxx
reg_dst=00, alu_src=0, mem_to_reg=00, reg_write=0, mem_write=0
alu_control=0000, branch=0, jump=0
其他指令类型
寄存器变化:
内存变化:
ALU: a=xxxxxxxx, b=xxxxxxxx, result=xxxxxxxx, zero=x
Next PC = 0000004c

==== 周期 30 ====
PC = 0000004c, 指令 = xxxxxxxx
控制信号: opcode=xxxxxx, funct=xxxxxx
reg_dst=00, alu_src=0, mem_to_reg=00, reg_write=0, mem_write=0
alu_control=0000, branch=0, jump=0
其他指令类型
寄存器变化:
内存变化:
ALU: a=xxxxxxxx, b=xxxxxxxx, result=xxxxxxxx, zero=x
Next PC = 00000050

==== 周期 31 ====
PC = 00000050, 指令 = xxxxxxxx
控制信号: opcode=xxxxxx, funct=xxxxxx
reg_dst=00, alu_src=0, mem_to_reg=00, reg_write=0, mem_write=0
alu_control=0000, branch=0, jump=0
其他指令类型
寄存器变化:
内存变化:
ALU: a=xxxxxxxx, b=xxxxxxxx, result=xxxxxxxx, zero=x
Next PC = 00000054

==== 周期 32 ====
PC = 00000054, 指令 = xxxxxxxx
控制信号: opcode=xxxxxx, funct=xxxxxx
reg_dst=00, alu_src=0, mem_to_reg=00, reg_write=0, mem_write=0
alu_control=0000, branch=0, jump=0
其他指令类型
寄存器变化:
内存变化:
ALU: a=xxxxxxxx, b=xxxxxxxx, result=xxxxxxxx, zero=x
Next PC = 00000058

==== 周期 33 ====
PC = 00000058, 指令 = xxxxxxxx
控制信号: opcode=xxxxxx, funct=xxxxxx
reg_dst=00, alu_src=0, mem_to_reg=00, reg_write=0, mem_write=0
alu_control=0000, branch=0, jump=0
其他指令类型
寄存器变化:
内存变化:
ALU: a=xxxxxxxx, b=xxxxxxxx, result=xxxxxxxx, zero=x
Next PC = 0000005c

==== 周期 34 ====
PC = 0000005c, 指令 = xxxxxxxx
控制信号: opcode=xxxxxx, funct=xxxxxx
reg_dst=00, alu_src=0, mem_to_reg=00, reg_write=0, mem_write=0
alu_control=0000, branch=0, jump=0
其他指令类型
寄存器变化:
内存变化:
ALU: a=xxxxxxxx, b=xxxxxxxx, result=xxxxxxxx, zero=x
Next PC = 00000060

==== 周期 35 ====
PC = 00000060, 指令 = xxxxxxxx
控制信号: opcode=xxxxxx, funct=xxxxxx
reg_dst=00, alu_src=0, mem_to_reg=00, reg_write=0, mem_write=0
alu_control=0000, branch=0, jump=0
其他指令类型
寄存器变化:
内存变化:
ALU: a=xxxxxxxx, b=xxxxxxxx, result=xxxxxxxx, zero=x
Next PC = 00000064

==== 周期 36 ====
PC = 00000064, 指令 = xxxxxxxx
控制信号: opcode=xxxxxx, funct=xxxxxx
reg_dst=00, alu_src=0, mem_to_reg=00, reg_write=0, mem_write=0
alu_control=0000, branch=0, jump=0
其他指令类型
寄存器变化:
内存变化:
ALU: a=xxxxxxxx, b=xxxxxxxx, result=xxxxxxxx, zero=x
Next PC = 00000068

==== 周期 37 ====
PC = 00000068, 指令 = xxxxxxxx
控制信号: opcode=xxxxxx, funct=xxxxxx
reg_dst=00, alu_src=0, mem_to_reg=00, reg_write=0, mem_write=0
alu_control=0000, branch=0, jump=0
其他指令类型
寄存器变化:
内存变化:
ALU: a=xxxxxxxx, b=xxxxxxxx, result=xxxxxxxx, zero=x
Next PC = 0000006c

==== 周期 38 ====
PC = 0000006c, 指令 = xxxxxxxx
控制信号: opcode=xxxxxx, funct=xxxxxx
reg_dst=00, alu_src=0, mem_to_reg=00, reg_write=0, mem_write=0
alu_control=0000, branch=0, jump=0
其他指令类型
寄存器变化:
内存变化:
ALU: a=xxxxxxxx, b=xxxxxxxx, result=xxxxxxxx, zero=x
Next PC = 00000070

==== 周期 39 ====
PC = 00000070, 指令 = xxxxxxxx
控制信号: opcode=xxxxxx, funct=xxxxxx
reg_dst=00, alu_src=0, mem_to_reg=00, reg_write=0, mem_write=0
alu_control=0000, branch=0, jump=0
其他指令类型
寄存器变化:
内存变化:
ALU: a=xxxxxxxx, b=xxxxxxxx, result=xxxxxxxx, zero=x
Next PC = 00000074

==== 周期 40 ====
PC = 00000074, 指令 = xxxxxxxx
控制信号: opcode=xxxxxx, funct=xxxxxx
reg_dst=00, alu_src=0, mem_to_reg=00, reg_write=0, mem_write=0
alu_control=0000, branch=0, jump=0
其他指令类型
寄存器变化:
内存变化:
ALU: a=xxxxxxxx, b=xxxxxxxx, result=xxxxxxxx, zero=x
Next PC = 00000078

==== 周期 41 ====
PC = 00000078, 指令 = xxxxxxxx
控制信号: opcode=xxxxxx, funct=xxxxxx
reg_dst=00, alu_src=0, mem_to_reg=00, reg_write=0, mem_write=0
alu_control=0000, branch=0, jump=0
其他指令类型
寄存器变化:
内存变化:
ALU: a=xxxxxxxx, b=xxxxxxxx, result=xxxxxxxx, zero=x
Next PC = 0000007c

==== 周期 42 ====
PC = 0000007c, 指令 = xxxxxxxx
控制信号: opcode=xxxxxx, funct=xxxxxx
reg_dst=00, alu_src=0, mem_to_reg=00, reg_write=0, mem_write=0
alu_control=0000, branch=0, jump=0
其他指令类型
寄存器变化:
内存变化:
ALU: a=xxxxxxxx, b=xxxxxxxx, result=xxxxxxxx, zero=x
Next PC = 00000080

==== 周期 43 ====
PC = 00000080, 指令 = xxxxxxxx
控制信号: opcode=xxxxxx, funct=xxxxxx
reg_dst=00, alu_src=0, mem_to_reg=00, reg_write=0, mem_write=0
alu_control=0000, branch=0, jump=0
其他指令类型
寄存器变化:
内存变化:
ALU: a=xxxxxxxx, b=xxxxxxxx, result=xxxxxxxx, zero=x
Next PC = 00000084

==== 周期 44 ====
PC = 00000084, 指令 = xxxxxxxx
控制信号: opcode=xxxxxx, funct=xxxxxx
reg_dst=00, alu_src=0, mem_to_reg=00, reg_write=0, mem_write=0
alu_control=0000, branch=0, jump=0
其他指令类型
寄存器变化:
内存变化:
ALU: a=xxxxxxxx, b=xxxxxxxx, result=xxxxxxxx, zero=x
Next PC = 00000088

==== 周期 45 ====
PC = 00000088, 指令 = xxxxxxxx
控制信号: opcode=xxxxxx, funct=xxxxxx
reg_dst=00, alu_src=0, mem_to_reg=00, reg_write=0, mem_write=0
alu_control=0000, branch=0, jump=0
其他指令类型
寄存器变化:
内存变化:
ALU: a=xxxxxxxx, b=xxxxxxxx, result=xxxxx